<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üì¶ VotexMap Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            background-color: #2c3e50;
            color: #ecf0f1;
        }
        
        body.light-theme {
            background-color: #ecf0f1;
            color: #2c3e50;
        }
        
        header {
            background-color: #1a2530;
            color: white;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .light-theme header {
            background-color: #3498db;
            color: white;
        }
        
        .toolbar {
            background-color: #34495e;
            padding: 8px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .light-theme .toolbar {
            background-color: #2980b9;
        }
        
        button {
            padding: 8px 12px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        button.active {
            background-color: #e74c3c;
        }
        
        .light-theme button {
            background-color: #3498db;
        }
        
        .light-theme button:hover {
            background-color: #2980b9;
        }
        
        .light-theme button.active {
            background-color: #e74c3c;
        }
        
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .canvas-container {
            flex: 3;
            position: relative;
            overflow: hidden;
            background-color: #2c3e50;
        }
        
        .light-theme .canvas-container {
            background-color: #bdc3c7;
        }
        
        #mapCanvas {
            position: absolute;
            background-color: #202020;
        }
        
        .light-theme #mapCanvas {
            background-color: #bdc3c7;
        }
        
        .sidebar {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 300px;
            background-color: #34495e;
            border-left: 1px solid #7f8c8d;
        }
        
        .light-theme .sidebar {
            background-color: #ecf0f1;
            border-left: 1px solid #bdc3c7;
        }
        
        .panel {
            margin: 10px;
            padding: 15px;
            background-color: #2c3e50;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .light-theme .panel {
            background-color: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .panel h3 {
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #7f8c8d;
            color: #ecf0f1;
        }
        
        .light-theme .panel h3 {
            color: #2c3e50;
            border-bottom: 1px solid #bdc3c7;
        }
        
        .objects-list {
            height: 200px;
            overflow-y: auto;
            border: 1px solid #7f8c8d;
            border-radius: 4px;
        }
        
        .light-theme .objects-list {
            border: 1px solid #bdc3c7;
        }
        
        .objects-list table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        
        .objects-list th, .objects-list td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #7f8c8d;
            color: #ecf0f1;
        }
        
        .light-theme .objects-list th, 
        .light-theme .objects-list td {
            color: #2c3e50;
            border-bottom: 1px solid #bdc3c7;
        }
        
        .objects-list tr:hover {
            background-color: rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }
        
        .light-theme .objects-list tr:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }
        
        .objects-list tr.selected {
            background-color: #3498db;
        }
        
        .light-theme .objects-list tr.selected {
            background-color: #e3f2fd;
        }
        
        .properties-form {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 10px;
        }
        
        .properties-form label {
            padding: 8px 0;
            font-weight: bold;
            color: #ecf0f1;
        }
        
        .light-theme .properties-form label {
            color: #2c3e50;
        }
        
        .properties-form input {
            padding: 8px;
            border: 1px solid #7f8c8d;
            border-radius: 4px;
            background-color: #34495e;
            color: #ecf0f1;
        }
        
        .light-theme .properties-form input {
            border: 1px solid #bdc3c7;
            background-color: white;
            color: #2c3e50;
        }
        
        .properties-form input:disabled {
            background-color: #2c3e50;
            color: #7f8c8d;
        }
        
        .light-theme .properties-form input:disabled {
            background-color: #f5f5f5;
            color: #bdc3c7;
        }
        
        .status-bar {
            padding: 8px 15px;
            background-color: #34495e;
            color: white;
            display: flex;
            justify-content: space-between;
        }
        
        .light-theme .status-bar {
            background-color: #2980b9;
            color: white;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background-color: #2c3e50;
            padding: 20px;
            border-radius: 8px;
            width: 400px;
            max-width: 90%;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .light-theme .modal-content {
            background-color: white;
        }
        
        .modal h2 {
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #7f8c8d;
            color: #ecf0f1;
        }
        
        .light-theme .modal h2 {
            color: #2c3e50;
            border-bottom: 1px solid #bdc3c7;
        }
        
        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }
        
        .grid-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
        }
        
        .grid-controls label {
            color: #ffffff;
        }
        
        .light-theme .grid-controls label {
            color: #2c3e50;
        }
        
        .grid-controls input {
            width: 60px;
            padding: 4px;
            border: 1px solid #7f8c8d;
            border-radius: 4px;
            background-color: #2c3e50;
            color: #ffffff;
        }
        
        .light-theme .grid-controls input {
            border: 1px solid #bdc3c7;
            background-color: white;
            color: #2c3e50;
        }
        
        .help-text {
            font-size: 12px;
            color: #95a5a6;
            margin-top: 5px;
        }
        
        .light-theme .help-text {
            color: #7f8c8d;
        }
        
        .tooltip {
            position: relative;
            display: inline-block;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 120px;
            background-color: #2c3e50;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -60px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px;
            background-color: #2ecc71;
            color: white;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            display: none;
            z-index: 1000;
        }
        
        .notification.error {
            background-color: #e74c3c;
        }
        
        .rotate-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: #ff9900;
            border-radius: 50%;
            cursor: grab;
            transform: translate(-50%, -50%);
            z-index: 10;
        }
        
        .rotate-handle:active {
            cursor: grabbing;
        }
        
        .grid-snap-mode {
            margin-left: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .grid-snap-mode select {
            padding: 4px;
            border: 1px solid #7f8c8d;
            border-radius: 4px;
            background-color: #2c3e50;
            color: #e3f2fd;
        }
        
        .light-theme .grid-snap-mode select {
            border: 1px solid #bdc3c7;
            background-color: white;
            color: #2c3e50;
        }

        /* New styles for custom properties */
        .custom-properties {
            margin-top: 15px;
            border-top: 1px solid #7f8c8d;
            padding-top: 15px;
        }
        
        .light-theme .custom-properties {
            border-top: 1px solid #bdc3c7;
        }
        
        .custom-properties-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .property-row {
            display: grid;
            grid-template-columns: 1fr 2fr auto;
            gap: 8px;
            margin-bottom: 8px;
            align-items: center;
        }
        
        .property-row input {
            padding: 6px;
        }
        
        .remove-property {
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 4px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        
        .remove-property:hover {
            background-color: #c0392b;
        }
        
        .add-property {
            background-color: #2ecc71;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            cursor: pointer;
        }
        
        .add-property:hover {
            background-color: #27ae60;
        }
        
        /* Documentation modal styles */
        .documentation-modal {
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .doc-section {
            margin-bottom: 20px;
        }
        
        .doc-section h3 {
            color: #3498db;
            margin-bottom: 10px;
        }
        
        .light-theme .doc-section h3 {
            color: #2980b9;
        }
        
        .doc-section ul {
            padding-left: 20px;
            margin-bottom: 10px;
        }
        
        .doc-section li {
            margin-bottom: 5px;
        }
        
        .doc-shortcut {
            display: inline-block;
            background-color: rgba(0,0,0,0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
        }
        
        .light-theme .doc-shortcut {
            background-color: rgba(0,0,0,0.05);
        }
        
        .doc-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px;
        }
        
        .doc-table th, .doc-table td {
            border: 1px solid #7f8c8d;
            padding: 8px;
            text-align: left;
        }
        
        .light-theme .doc-table th, 
        .light-theme .doc-table td {
            border: 1px solid #bdc3c7;
        }
        
        .doc-table th {
            background-color: rgba(0,0,0,0.1);
        }
        
        .light-theme .doc-table th {
            background-color: rgba(0,0,0,0.05);
        }
        
        /* Custom Properties Modal */
        .custom-props-modal {
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
        }
        
        .custom-props-container {
            max-height: 50vh;
            overflow-y: auto;
            margin: 15px 0;
            padding: 10px;
            border: 1px solid #7f8c8d;
            border-radius: 4px;
        }
        
        .light-theme .custom-props-container {
            border: 1px solid #bdc3c7;
        }
    </style>
</head>
<body>
    <header>
        <h1>üì¶ VotexMap Editor v0.4</h1>
        <div>
            <button id="newBtn">üÜï New</button>
            <button id="openBtn">üìÇ Open</button>
            <button id="saveBtn">üíæ Save</button>
            <button id="undoBtn" title="Undo (Ctrl+Z)">‚Ü©Ô∏è Undo</button>
            <button id="redoBtn" title="Redo (Ctrl+Y)">‚Ü™Ô∏è Redo</button>
            <button id="mapSettingsBtn">‚ÑπÔ∏è Map Settings</button>
            <button id="themeToggleBtn">üé® Dark/Light</button>
            <button id="docBtn">üìÑ Documentation</button>
        </div>
    </header>
    
    <div class="toolbar">
        <button id="selectBtn" class="active">‚ûï Select</button>
        <button id="brushBtn">üñåÔ∏è Brush</button>
        <button id="playerStartBtn">üéÆ Player Start</button>
        <button id="triggerBtn">üïπÔ∏è Trigger</button>
        <button id="lightBtn">üí° Light</button>
        <button id="propBtn">üì¶ Prop</button>
        
        <div class="grid-controls">
            <label>
                <input type="checkbox" id="snapToGridCheckbox" checked>
                Snap to Grid
            </label>
            <label>
                Grid Size:
                <input type="number" id="gridSizeInput" value="64" min="1" max="500">
            </label>
        </div>
        
        <div class="grid-snap-mode">
            <label>‚åó Snap Mode:</label>
            <select id="gridSnapMode">
                <option value="center">Center to Grid</option>
                <option value="edge">Edge to Grid</option>
            </select>
        </div>
        
        <button id="zoomInBtn">‚ûï Zoom In</button>
        <button id="zoomOutBtn">‚ûñ Zoom Out</button>
        <button id="resetViewBtn">üîé Reset View</button>
        <button id="deleteBtn" style="background-color: #f04b39;">üóëÔ∏è Delete Object</button>
    </div>
    
    <div class="main-container">
        <div class="canvas-container">
            <canvas id="mapCanvas"></canvas>
            <div id="rotateHandle" class="rotate-handle" style="display: none;"></div>
        </div>
        
        <div class="sidebar">
            <div class="panel">
                <h3>Objects</h3>
                <div class="objects-list">
                    <table id="objectsTable">
                        <thead>
                            <tr>
                                <th>ID</th>
                                <th>Type</th>
                                <th>X</th>
                                <th>Y</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Objects will be listed here -->
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="panel">
                <h3>Properties</h3>
                <div class="properties-form">
                    <label for="propId">ID:</label>
                    <input type="text" id="propId" disabled>
                    
                    <label for="propType">Type:</label>
                    <input type="text" id="propType" disabled>
                    
                    <label for="propX">X:</label>
                    <input type="number" id="propX" step="0.1">
                    
                    <label for="propY">Y:</label>
                    <input type="number" id="propY" step="0.1">
                    
                    <label for="propWidth">Width:</label>
                    <input type="number" id="propWidth" step="0.1">
                    
                    <label for="propHeight">Height:</label>
                    <input type="number" id="propHeight" step="0.1">
                    
                    <label for="propAngle">Angle:</label>
                    <input type="number" id="propAngle" step="0.1" min="0" max="360">
                    
                    <div></div>
                    <div class="help-text">Use mouse wheel to rotate objects</div>
                </div>

                <!-- Button to open custom properties modal -->
                <button id="openCustomPropsBtn" class="add-property" style="margin-top: 15px; width: 100%;">Edit Custom Properties</button>
            </div>
        </div>
    </div>
    
    <div class="status-bar">
        <div>X: <span id="cursorX">0</span> | Y: <span id="cursorY">0</span> | Mode: <span id="modeDisplay">Select</span></div>
        <div>Scale: <span id="scaleDisplay">100%</span> | Grid: <span id="gridSizeDisplay">64</span> | Snap: <span id="snapModeDisplay">Center</span></div>
    </div>
    
    <div class="notification" id="notification">Operation completed successfully</div>
    
    <!-- Modals -->
    <div class="modal" id="newMapModal">
        <div class="modal-content">
            <h2>Create New Map</h2>
            <div class="properties-form">
                <label for="newMapName">Name:</label>
                <input type="text" id="newMapName" value="New Map for VE">
                
                <label for="newMapAuthor">Author:</label>
                <input type="text" id="newMapAuthor" value="-">
                
                <label for="newMapDescription">Description:</label>
                <input type="text" id="newMapDescription" value="-">
            </div>
            <div class="modal-buttons">
                <button id="cancelNewMapBtn">Cancel</button>
                <button id="confirmNewMapBtn">Create</button>
            </div>
        </div>
    </div>

    <div class="modal" id="mapSettingsModal">
        <div class="modal-content">
            <h2>Map Settings</h2>
            <div class="properties-form">
                <label for="mapName">Name:</label>
                <input type="text" id="mapName">

                <label for="mapAuthor">Author:</label>
                <input type="text" id="mapAuthor">

                <label for="mapDescription">Description:</label>
                <input type="text" id="mapDescription">

                <label for="mapGridSize">Grid Size:</label>
                <input type="number" id="mapGridSize" min="1" max="500">
            </div>
            <div class="modal-buttons">
                <button id="cancelMapSettingsBtn">Cancel</button>
                <button id="confirmMapSettingsBtn">Apply</button>
            </div>
        </div>
    </div>

    <!-- Custom Properties Modal -->
    <div class="modal" id="customPropsModal">
        <div class="modal-content custom-props-modal">
            <h2>Custom Properties</h2>
            <div class="custom-props-container" id="customPropertiesContainer">
                <!-- Custom properties will be added here -->
            </div>
            <div class="custom-properties-header">
                <button id="addPropertyBtn" class="add-property">+ Add Property</button>
            </div>
            <div class="modal-buttons">
                <button id="cancelCustomPropsBtn">Cancel</button>
                <button id="saveCustomPropsBtn">Save</button>
            </div>
        </div>
    </div>

    <!-- Documentation Modal -->
    <div class="modal" id="documentationModal">
        <div class="modal-content documentation-modal">
            <h2>VotexMap Editor Documentation</h2>
            
            <div class="doc-section">
                <h3>Overview</h3>
                <p>VotexMap Editor is a tool for creating maps for Votex Engine. It allows you to place and configure various objects including brushes, player start positions, triggers, lights, and props.</p>
            </div>
            
            <div class="doc-section">
                <h3>Tools</h3>
                <table class="doc-table">
                    <tr>
                        <th>Tool</th>
                        <th>Description</th>
                        <th>Shortcut</th>
                    </tr>
                    <tr>
                        <td>Select</td>
                        <td>Select and manipulate objects</td>
                        <td>Q</td>
                    </tr>
                    <tr>
                        <td>Brush</td>
                        <td>Create solid geometry (walls, floors)</td>
                        <td>B</td>
                    </tr>
                    <tr>
                        <td>Player Start</td>
                        <td>Place player spawn point</td>
                        <td>P</td>
                    </tr>
                    <tr>
                        <td>Trigger</td>
                        <td>Create interactive triggers</td>
                        <td>T</td>
                    </tr>
                    <tr>
                        <td>Light</td>
                        <td>Place light sources</td>
                        <td>L</td>
                    </tr>
                    <tr>
                        <td>Prop</td>
                        <td>Place decorative objects</td>
                        <td>O</td>
                    </tr>
                </table>
            </div>
            
            <div class="doc-section">
                <h3>Controls</h3>
                <ul>
                    <li><span class="doc-shortcut">Left Click</span> - Place/Select object</li>
                    <li><span class="doc-shortcut">Right Click + Drag</span> - Pan view</li>
                    <li><span class="doc-shortcut">Mouse Wheel</span> - Zoom in/out</li>
                    <li><span class="doc-shortcut">Ctrl + Mouse Wheel</span> - Rotate selected object</li>
                    <li><span class="doc-shortcut">Delete</span> - Delete selected object</li>
                    <li><span class="doc-shortcut">G</span> - Toggle grid snapping</li>
                    <li><span class="doc-shortcut">Arrow Keys</span> - Nudge selected object</li>
                    <li><span class="doc-shortcut">Ctrl+Z</span> - Undo</li>
                    <li><span class="doc-shortcut">Ctrl+Y</span> - Redo</li>
                    <li><span class="doc-shortcut">Escape</span> - Cancel current action</li>
                </ul>
            </div>
            
            <div class="doc-section">
                <h3>Object Properties</h3>
                <p>All objects have standard properties like position, size, and rotation. You can also add custom properties to any object:</p>
                <ul>
                    <li>Click the <strong>Edit Custom Properties</strong> button in the Properties panel</li>
                    <li>Enter a property name (key) and value</li>
                    <li>Use the trash icon to remove properties</li>
                    <li>Custom properties are automatically saved with your map</li>
                </ul>
            </div>
            
            <div class="doc-section">
                <h3>File Format</h3>
                <p>Maps are saved in JSON format with .vme extension. The format includes:</p>
                <ul>
                    <li>Map metadata (name, author, description)</li>
                    <li>Grid settings</li>
                    <li>Array of objects with their properties</li>
                    <li>Custom properties for each object</li>
                </ul>
            </div>
            
            <div class="modal-buttons">
                <button id="closeDocBtn">Close</button>
            </div>
        </div>
    </div>

    <script>
        let isDirty = false;
        let isDarkTheme = true;

        // –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let GRID_SIZE = 64;
        const OBJECT_TYPES = ["brush", "player_start", "trigger", "light", "prop"];
        
        // –°–æ—Å—Ç–æ—è–Ω–∏–µ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞
        let mapData = {
            version: "1.0",
            objects: [],
            metadata: {
                name: "NewMap",
                author: "-",
                description: "-"
            }
        };
        
        let selectedObject = null;
        let dragging = false;
        let rotating = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let offsetX = 0;
        let offsetY = 0;
        let scale = 1.0;
        let snapToGrid = true;
        let snapMode = "edge"; // "center" or "edge"
        let currentMode = "select";
        let nextObjectId = 1;
        let isCreatingbrush = false;
        let brushStartX = 0;
        let brushStartY = 0;
        let brushEndX = 0;
        let brushEndY = 0;
        let startOffsetX = 0;
        let startOffsetY = 0;
        
        // –ù–æ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è
        let startObjectX = 0;
        let startObjectY = 0;
        
        // –ò—Å—Ç–æ—Ä–∏—è –¥–ª—è –æ—Ç–º–µ–Ω—ã/–ø–æ–≤—Ç–æ—Ä–∞
        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY = 50;
        
        // –≠–ª–µ–º–µ–Ω—Ç—ã DOM
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        const cursorXElem = document.getElementById('cursorX');
        const cursorYElem = document.getElementById('cursorY');
        const scaleDisplayElem = document.getElementById('scaleDisplay');
        const gridSizeDisplayElem = document.getElementById('gridSizeDisplay');
        const snapModeDisplayElem = document.getElementById('snapModeDisplay');
        const gridSizeInput = document.getElementById('gridSizeInput');
        const gridSnapMode = document.getElementById('gridSnapMode');
        const objectsTableBody = document.querySelector('#objectsTable tbody');
        const modeDisplayElem = document.getElementById('modeDisplay');
        const notificationElem = document.getElementById('notification');
        const rotateHandle = document.getElementById('rotateHandle');
        const customPropertiesContainer = document.getElementById('customPropertiesContainer');
        const addPropertyBtn = document.getElementById('addPropertyBtn');
        const openCustomPropsBtn = document.getElementById('openCustomPropsBtn');
        const customPropsModal = document.getElementById('customPropsModal');
        const saveCustomPropsBtn = document.getElementById('saveCustomPropsBtn');
        const cancelCustomPropsBtn = document.getElementById('cancelCustomPropsBtn');
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        function init() {
            setupCanvas();
            setupEventListeners();
            resetView();
            draw();
            updateHistoryButtons();
            showNotification("Editor initialized successfully");
        }
        
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ö–æ–ª—Å—Ç–∞
        function setupCanvas() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        }
        
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            draw();
        }
        
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å–æ–±—ã—Ç–∏–π
        function setupEventListeners() {
            // –ö–Ω–æ–ø–∫–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
            document.getElementById('selectBtn').addEventListener('click', () => setMode('select'));
            document.getElementById('brushBtn').addEventListener('click', () => setMode('brush'));
            document.getElementById('playerStartBtn').addEventListener('click', () => setMode('player_start'));
            document.getElementById('triggerBtn').addEventListener('click', () => setMode('trigger'));
            document.getElementById('lightBtn').addEventListener('click', () => setMode('light'));
            document.getElementById('propBtn').addEventListener('click', () => setMode('prop'));
            
            // –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤–∏–¥–æ–º
            document.getElementById('zoomInBtn').addEventListener('click', () => zoomAtCenter(scale * 1.2));
            document.getElementById('zoomOutBtn').addEventListener('click', () => zoomAtCenter(scale / 1.2));
            document.getElementById('resetViewBtn').addEventListener('click', resetView);
            document.getElementById('snapToGridCheckbox').addEventListener('change', (e) => {
                snapToGrid = e.target.checked;
                draw();
            });
            
            // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–æ–º —Å–µ—Ç–∫–∏
            gridSizeInput.addEventListener('change', (e) => {
                GRID_SIZE = parseInt(e.target.value) || 50;
                gridSizeDisplayElem.textContent = GRID_SIZE;
                draw();
            });
            
            // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–µ–∂–∏–º–æ–º –ø—Ä–∏–≤—è–∑–∫–∏
            gridSnapMode.addEventListener('change', (e) => {
                snapMode = e.target.value;
                snapModeDisplayElem.textContent = snapMode === "center" ? "Center" : "Edge";
                draw();
            });
            
            // –ö–Ω–æ–ø–∫–∏ —Ñ–∞–π–ª–æ–≤—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
            document.getElementById('newBtn').addEventListener('click', showNewMapModal);
            document.getElementById('openBtn').addEventListener('click', openMap);
            document.getElementById('saveBtn').addEventListener('click', saveMap);
            document.getElementById('confirmNewMapBtn').addEventListener('click', createNewMap);
            document.getElementById('cancelNewMapBtn').addEventListener('click', hideNewMapModal);
            
            // –ö–Ω–æ–ø–∫–∏ –æ—Ç–º–µ–Ω—ã/–ø–æ–≤—Ç–æ—Ä–∞
            document.getElementById('undoBtn').addEventListener('click', undo);
            document.getElementById('redoBtn').addEventListener('click', redo);
            
            // –ö–Ω–æ–ø–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è
            document.getElementById('deleteBtn').addEventListener('click', deleteSelectedObject);
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–≤–æ–π—Å—Ç–≤ –æ–±—ä–µ–∫—Ç–æ–≤
            document.getElementById('propX').addEventListener('change', updateObjectProperties);
            document.getElementById('propY').addEventListener('change', updateObjectProperties);
            document.getElementById('propWidth').addEventListener('change', updateObjectProperties);
            document.getElementById('propHeight').addEventListener('change', updateObjectProperties);
            document.getElementById('propAngle').addEventListener('change', updateObjectProperties);
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π —Ö–æ–ª—Å—Ç–∞
            canvas.addEventListener('mousedown', onCanvasMouseDown);
            canvas.addEventListener('mousemove', onCanvasMouseMove);
            canvas.addEventListener('mouseup', onCanvasMouseUp);
            canvas.addEventListener('wheel', onCanvasWheel);
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è —Ä—É—á–∫–∏ –≤—Ä–∞—â–µ–Ω–∏—è
            rotateHandle.addEventListener('mousedown', onRotateHandleMouseDown);
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ –æ–±—ä–µ–∫—Ç–∞ –∏–∑ —Ç–∞–±–ª–∏—Ü—ã
            objectsTableBody.addEventListener('click', onObjectsTableClick);
            
            // Map Settings
            document.getElementById("mapSettingsBtn").addEventListener("click", () => {
                document.getElementById("mapSettingsModal").style.display = "flex";
                document.getElementById("mapName").value = mapData.metadata.name;
                document.getElementById("mapAuthor").value = mapData.metadata.author;
                document.getElementById("mapDescription").value = mapData.metadata.description;
                document.getElementById("mapGridSize").value = GRID_SIZE;
            });
            document.getElementById("cancelMapSettingsBtn").addEventListener("click", () => {
                document.getElementById("mapSettingsModal").style.display = "none";
            });
            document.getElementById("confirmMapSettingsBtn").addEventListener("click", () => {
                mapData.metadata.name = document.getElementById("mapName").value;
                mapData.metadata.author = document.getElementById("mapAuthor").value;
                mapData.metadata.description = document.getElementById("mapDescription").value;
                GRID_SIZE = parseInt(document.getElementById("mapGridSize").value) || GRID_SIZE;
                gridSizeInput.value = GRID_SIZE;
                gridSizeDisplayElem.textContent = GRID_SIZE;
                document.getElementById("mapSettingsModal").style.display = "none";
                markDirty();
                draw();
                showNotification("Map settings updated");
            });

            // Dark/Light Theme
            document.getElementById("themeToggleBtn").addEventListener("click", toggleTheme);
            
            // Documentation
            document.getElementById("docBtn").addEventListener("click", () => {
                document.getElementById("documentationModal").style.display = "flex";
            });
            document.getElementById("closeDocBtn").addEventListener("click", () => {
                document.getElementById("documentationModal").style.display = "none";
            });
            
            // Custom properties
            openCustomPropsBtn.addEventListener('click', openCustomPropsModal);
            addPropertyBtn.addEventListener('click', addCustomPropertyField);
            saveCustomPropsBtn.addEventListener('click', saveCustomProperties);
            cancelCustomPropsBtn.addEventListener('click', closeCustomPropsModal);
        }
        
        // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
        function screenToWorldX(screenX) {
            return (screenX - canvas.getBoundingClientRect().left - offsetX) / scale;
        }
        
        function screenToWorldY(screenY) {
            return (screenY - canvas.getBoundingClientRect().top - offsetY) / scale;
        }
        
        function worldToScreenX(worldX) {
            return worldX * scale + offsetX;
        }
        
        function worldToScreenY(worldY) {
            return worldY * scale + offsetY;
        }
        
        // –§—É–Ω–∫—Ü–∏—è –ø—Ä–∏–≤—è–∑–∫–∏ –∫ —Å–µ—Ç–∫–µ —Å —É—á–µ—Ç–æ–º —Ä–µ–∂–∏–º–∞
        function snapToGridPosition(x, y, obj = null) {
            if (!snapToGrid) return { x, y };
            
            if (snapMode === "center") {
                // –ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∞—è –ø—Ä–∏–≤—è–∑–∫–∞ —Ü–µ–Ω—Ç—Ä–∞ –∫ —Å–µ—Ç–∫–µ
                return {
                    x: Math.round(x / GRID_SIZE) * GRID_SIZE,
                    y: Math.round(y / GRID_SIZE) * GRID_SIZE
                };
            } else {
                // –ü—Ä–∏–≤—è–∑–∫–∞ –∫—Ä–∞–µ–≤ –∫ —Å–µ—Ç–∫–µ (–¥–ª—è –æ–±—ä–µ–∫—Ç–æ–≤ —Å —Ä–∞–∑–º–µ—Ä–∞–º–∏)
                if (obj && (obj.type === "brush" || obj.type === "trigger")) {
                    const width = obj.width || 100;
                    const height = obj.height || 64;
                    
                    // –í—ã—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Ç–∞–∫, —á—Ç–æ–±—ã –∫—Ä–∞—è –æ–±—ä–µ–∫—Ç–∞ —Å–æ–≤–ø–∞–¥–∞–ª–∏ —Å –ª–∏–Ω–∏—è–º–∏ —Å–µ—Ç–∫–∏
                    const halfWidth = width / 2;
                    const halfHeight = height / 2;
                    
                    // –í—ã—á–∏—Å–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é —Ü–µ–Ω—Ç—Ä–∞, —á—Ç–æ–±—ã –∫—Ä–∞—è —Å–æ–≤–ø–∞–¥–∞–ª–∏ —Å —Å–µ—Ç–∫–æ–π
                    const snappedX = Math.round((x - halfWidth) / GRID_SIZE) * GRID_SIZE + halfWidth;
                    const snappedY = Math.round((y - halfHeight) / GRID_SIZE) * GRID_SIZE + halfHeight;
                    
                    return { x: snappedX, y: snappedY };
                } else {
                    // –î–ª—è –æ–±—ä–µ–∫—Ç–æ–≤ –±–µ–∑ —Ä–∞–∑–º–µ—Ä–æ–≤ –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—ã—á–Ω—É—é –ø—Ä–∏–≤—è–∑–∫—É
                    return {
                        x: Math.round(x / GRID_SIZE) * GRID_SIZE,
                        y: Math.round(y / GRID_SIZE) * GRID_SIZE
                    };
                }
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π –º—ã—à–∏
        function onCanvasMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const x = screenToWorldX(e.clientX);
            const y = screenToWorldY(e.clientY);
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∫–ª–∏–∫–Ω—É–ª–∏ –ª–∏ –º—ã –Ω–∞ —Ä—É—á–∫–µ –≤—Ä–∞—â–µ–Ω–∏—è
            if (selectedObject && isOverRotateHandle(e.clientX, e.clientY)) {
                rotating = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                return;
            }
            
            if (e.button === 0) { // –õ–µ–≤–∞—è –∫–Ω–æ–ø–∫–∞ –º—ã—à–∏
                if (currentMode === "select") {
                    const clickedObj = findObjectAt(x, y);
                    if (clickedObj) {
                        selectObject(clickedObj);
                        dragging = true;
                        dragStartX = e.clientX;
                        dragStartY = e.clientY;
                        startOffsetX = offsetX;
                        startOffsetY = offsetY;
                        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏—Å—Ö–æ–¥–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –æ–±—ä–µ–∫—Ç–∞
                        startObjectX = clickedObj.x;
                        startObjectY = clickedObj.y;
                        saveState();
                    } else {
                        selectObject(null);
                    }
                } else if (currentMode === "brush") {
                    // –ù–∞—á–∞–ª–æ —Å–æ–∑–¥–∞–Ω–∏—è —Å—Ç–µ–Ω—ã
                    isCreatingbrush = true;
                    const snappedPos = snapToGridPosition(x, y);
                    brushStartX = snappedPos.x;
                    brushStartY = snappedPos.y;
                    brushEndX = brushStartX;
                    brushEndY = brushStartY;
                    saveState();
                } else {
                    // –†–µ–∂–∏–º –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –æ–±—ä–µ–∫—Ç–∞
                    const snappedPos = snapToGridPosition(x, y);
                    addObject(currentMode, snappedPos.x, snappedPos.y);
                    saveState();
                }
            } else if (e.button === 2) { // –ü—Ä–∞–≤–∞—è –∫–Ω–æ–ø–∫–∞ –º—ã—à–∏ - –ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                startOffsetX = offsetX;
                startOffsetY = offsetY;
                canvas.style.cursor = 'grabbing';
            }
        }
        
        function onCanvasMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const x = screenToWorldX(e.clientX);
            const y = screenToWorldY(e.clientY);
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –∫—É—Ä—Å–æ—Ä–∞ –≤ —Å—Ç–∞—Ç—É—Å–Ω–æ–π —Å—Ç—Ä–æ–∫–µ
            cursorXElem.textContent = Math.round(x);
            cursorYElem.textContent = Math.round(y);
            
            if (rotating && selectedObject) {
                // –í—Ä–∞—â–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞
                const centerX = worldToScreenX(selectedObject.x);
                const centerY = worldToScreenY(selectedObject.y);
                
                const angle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * 180 / Math.PI;
                selectedObject.angle = Math.round(angle);
                
                document.getElementById('propAngle').value = selectedObject.angle;
                updateRotateHandlePosition();
                draw();
                return;
            }
            
            if (dragging && selectedObject) {
                // –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞ - –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –ß–ê–°–¢–¨
                const worldDX = (e.clientX - dragStartX) / scale;
                const worldDY = (e.clientY - dragStartY) / scale;
                
                let newX = startObjectX + worldDX;
                let newY = startObjectY + worldDY;
                
                // –ü—Ä–∏–º–µ–Ω—è–µ–º –ø—Ä–∏–≤—è–∑–∫—É –∫ —Å–µ—Ç–∫–µ
                if (snapToGrid) {
                    const snappedPos = snapToGridPosition(newX, newY, selectedObject);
                    newX = snappedPos.x;
                    newY = snappedPos.y;
                }
                
                selectedObject.x = newX;
                selectedObject.y = newY;
                
                updateRotateHandlePosition();
                draw();
                updatePropertiesPanel();
                updateObjectsTable();
            } else if (e.buttons === 2) {
                // –ü–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ
                offsetX = startOffsetX + (e.clientX - dragStartX);
                offsetY = startOffsetY + (e.clientY - dragStartY);
                draw();
            } else if (isCreatingbrush) {
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω–µ—á–Ω–æ–π —Ç–æ—á–∫–∏ —Å—Ç–µ–Ω—ã
                const snappedPos = snapToGridPosition(x, y);
                brushEndX = snappedPos.x;
                brushEndY = snappedPos.y;
                draw();
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—É—Ä—Å–æ—Ä–∞ –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏ –Ω–∞ —Ä—É—á–∫—É –≤—Ä–∞—â–µ–Ω–∏—è
            if (selectedObject && isOverRotateHandle(e.clientX, e.clientY)) {
                canvas.style.cursor = 'grab';
            } else if (currentMode === "select") {
                canvas.style.cursor = 'default';
            } else {
                canvas.style.cursor = 'crosshair';
            }
        }
        
        function onCanvasMouseUp(e) {
            if (e.button === 0) {
                if (isCreatingbrush) {
                    // –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Å–æ–∑–¥–∞–Ω–∏—è —Å—Ç–µ–Ω—ã
                    finishbrush();
                }
                dragging = false;
                rotating = false;
            } else if (e.button === 2) {
                canvas.style.cursor = 'default';
            }
        }
        
        function onRotateHandleMouseDown(e) {
            rotating = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            e.stopPropagation();
        }
        
        function onCanvasWheel(e) {
            e.preventDefault();
            
            if (e.ctrlKey && selectedObject) {
                // –í—Ä–∞—â–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞ –ø—Ä–∏ –∑–∞–∂–∞—Ç–æ–º Ctrl
                const rotationAmount = e.deltaY > 0 ? -5 : 5;
                if (!selectedObject.angle) selectedObject.angle = 0;
                selectedObject.angle = (selectedObject.angle + rotationAmount) % 360;
                if (selectedObject.angle < 0) selectedObject.angle += 360;
                
                document.getElementById('propAngle').value = selectedObject.angle;
                updateRotateHandlePosition();
                draw();
                return;
            }
            
            // –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ —Ç–æ—á–∫–µ –∫—É—Ä—Å–æ—Ä–∞
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const zoomIntensity = 0.1;
            const wheel = e.deltaY < 0 ? 1 : -1;
            
            // –í—ã—á–∏—Å–ª—è–µ–º –º–∏—Ä–æ–≤—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–æ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è
            const worldX = screenToWorldX(mouseX);
            const worldY = screenToWorldY(mouseY);
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ
            const newScale = scale + wheel * zoomIntensity * scale;
            setScale(newScale, worldX, worldY);
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –∫—É—Ä—Å–æ—Ä –Ω–∞–¥ —Ä—É—á–∫–æ–π –≤—Ä–∞—â–µ–Ω–∏—è
        function isOverRotateHandle(x, y) {
            if (!selectedObject) return false;
            
            const handleX = parseFloat(rotateHandle.style.left);
            const handleY = parseFloat(rotateHandle.style.top);
            const distance = Math.sqrt(Math.pow(x - handleX, 2) + Math.pow(y - handleY, 2));
            
            return distance <= 15; // 15px radius
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ —Ä—É—á–∫–∏ –≤—Ä–∞—â–µ–Ω–∏—è
        function updateRotateHandlePosition() {
            if (!selectedObject) {
                rotateHandle.style.display = 'none';
                return;
            }
            
            const x = worldToScreenX(selectedObject.x);
            const y = worldToScreenY(selectedObject.y);
            
            // –ü–æ–∑–∏—Ü–∏—è —Ä—É—á–∫–∏ –≤—Ä–∞—â–µ–Ω–∏—è (–Ω–∞ 40px –≤—ã—à–µ —Ü–µ–Ω—Ç—Ä–∞ –æ–±—ä–µ–∫—Ç–∞)
            const angle = selectedObject.angle ? selectedObject.angle * Math.PI / 180 : 0;
            const handleDistance = 40 * scale;
            const handleX = x + Math.sin(angle) * handleDistance;
            const handleY = y - Math.cos(angle) * handleDistance;
            
            rotateHandle.style.left = handleX + 'px';
            rotateHandle.style.top = handleY + 'px';
            rotateHandle.style.display = 'block';
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç–µ–Ω—ã
        function finishbrush() {
            if (!isCreatingbrush) return;
            
            const width = Math.abs(brushEndX - brushStartX);
            const height = Math.abs(brushEndY - brushStartY);
            
            // –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä —Å—Ç–µ–Ω—ã
            if (width < 5 || height < 5) {
                isCreatingbrush = false;
                draw();
                return;
            }
            
            const centerX = (brushStartX + brushEndX) / 2;
            const centerY = (brushStartY + brushEndY) / 2;
            
            const newObj = {
                id: `obj_${nextObjectId++}`,
                type: "brush",
                x: centerX,
                y: centerY,
                width: width,
                height: height,
                angle: 0,
                properties: {}
            };
            
            mapData.objects.push(newObj);
            selectObject(newObj);
            isCreatingbrush = false;
            draw();
            updateObjectsTable();
        }
        
        // –ü–æ–∏—Å–∫ –æ–±—ä–µ–∫—Ç–∞ –ø–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º
        function findObjectAt(x, y) {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–±—ä–µ–∫—Ç—ã –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ (—Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑)
            for (let i = mapData.objects.length - 1; i >= 0; i--) {
                const obj = mapData.objects[i];
                const objX = obj.x || 0;
                const objY = obj.y || 0;
                
                if (obj.type === "brush") {
                    const width = obj.width || 100;
                    const height = obj.height || 20;
                    
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è –≤ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫
                    if (Math.abs(x - objX) <= width/2 && Math.abs(y - objY) <= height/2) {
                        return obj;
                    }
                } else {
                    // –î–ª—è –¥—Ä—É–≥–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ä–∞–¥–∏—É—Å
                    const radius = 15;
                    const distance = Math.sqrt((x - objX)**2 + (y - objY)**2);
                    if (distance <= radius) {
                        return obj;
                    }
                }
            }
            
            return null;
        }
        
        // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞–º–∏
        function addObject(type, x, y) {
            const newObj = {
                id: `obj_${nextObjectId++}`,
                type: type,
                x: x,
                y: y,
                properties: {}
            };
            
            // –î–æ–±–∞–≤–ª—è–µ–º —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞
            if (type === "brush") {
                newObj.width = 100;
                newObj.height = 20;
                newObj.angle = 0;
            } else if (type === "player_start") {
                newObj.angle = 0;
            } else if (type === "trigger") {
                newObj.width = 64;
                newObj.height = 64;
                newObj.angle = 0;
            }
            
            mapData.objects.push(newObj);
            selectObject(newObj);
            draw();
            updateObjectsTable();
            showNotification(`Added ${type.replace('_', ' ')} object`);
        }
        
        function deleteSelectedObject() {
            if (!selectedObject) {
                showNotification("No object selected to delete", true);
                return;
            }
            
            const index = mapData.objects.indexOf(selectedObject);
            if (index !== -1) {
                saveState();
                mapData.objects.splice(index, 1);
                selectObject(null);
                draw();
                updateObjectsTable();
                showNotification("Object deleted");
            }
        }
        
        function selectObject(obj) {
            selectedObject = obj;
            updateRotateHandlePosition();
            draw();
            updatePropertiesPanel();
            updateObjectsTable();
        }
        
        // –û—Ç—Ä–∏—Å–æ–≤–∫–∞
        function draw() {
            // –û—á–∏—Å—Ç–∫–∞ —Ö–æ–ª—Å—Ç–∞
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // –†–∏—Å–æ–≤–∞–Ω–∏–µ —Å–µ—Ç–∫–∏
            drawGrid();
            
            // –†–∏—Å–æ–≤–∞–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–Ω–æ–π —Å—Ç–µ–Ω—ã, –µ—Å–ª–∏ –æ–Ω–∞ —Å–æ–∑–¥–∞–µ—Ç—Å—è
            if (isCreatingbrush) {
                drawTemporarybrush();
            }
            
            // –†–∏—Å–æ–≤–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤
            mapData.objects.forEach(obj => {
                drawObject(obj);
            });
            
            // –í—ã–¥–µ–ª–µ–Ω–∏–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞
            if (selectedObject) {
                highlightObject(selectedObject);
            }
        }
        
        function drawGrid() {
            const visibleLeft = screenToWorldX(0);
            const visibleRight = screenToWorldX(canvas.width);
            const visibleTop = screenToWorldY(0);
            const visibleBottom = screenToWorldY(canvas.height);
            
            const startX = Math.floor(visibleLeft / GRID_SIZE) * GRID_SIZE;
            const endX = Math.ceil(visibleRight / GRID_SIZE) * GRID_SIZE;
            const startY = Math.floor(visibleTop / GRID_SIZE) * GRID_SIZE;
            const endY = Math.ceil(visibleBottom / GRID_SIZE) * GRID_SIZE;
            
            // –†–∏—Å—É–µ–º —Å–µ—Ç–∫—É
            ctx.strokeStyle = isDarkTheme ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.2)';
            ctx.setLineDash([2, 2]);
            ctx.lineWidth = 1;
            
            for (let x = startX; x <= endX; x += GRID_SIZE) {
                const screenX = worldToScreenX(x);
                ctx.beginPath();
                ctx.moveTo(screenX, 0);
                ctx.lineTo(screenX, canvas.height);
                ctx.stroke();
            }
            
            for (let y = startY; y <= endY; y += GRID_SIZE) {
                const screenY = worldToScreenY(y);
                ctx.beginPath();
                ctx.moveTo(0, screenY);
                ctx.lineTo(canvas.width, screenY);
                ctx.stroke();
            }
            
            ctx.setLineDash([]);
            
            // –†–∏—Å—É–µ–º –æ—Å–∏
            const originX = worldToScreenX(0);
            const originY = worldToScreenY(0);
            
            if (originX >= 0 && originX <= canvas.width) {
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(originX, 0);
                ctx.lineTo(originX, canvas.height);
                ctx.stroke();
            }
            
            if (originY >= 0 && originY <= canvas.height) {
                ctx.strokeStyle = 'green';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, originY);
                ctx.lineTo(canvas.width, originY);
                ctx.stroke();
            }
        }
        
        function drawTemporarybrush() {
            const startX = worldToScreenX(brushStartX);
            const startY = worldToScreenY(brushStartY);
            const endX = worldToScreenX(brushEndX);
            const endY = worldToScreenY(brushEndY);
            
            const width = Math.abs(endX - startX);
            const height = Math.abs(endY - startY);
            const centerX = (startX + endX) / 2;
            const centerY = (startY + endY) / 2;
            
            ctx.fillStyle = 'rgba(173, 216, 230, 0.5)';
            ctx.strokeStyle = 'blue';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.rect(centerX - width/2, centerY - height/2, width, height);
            ctx.fill();
            ctx.stroke();
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã
            ctx.fillStyle = isDarkTheme ? 'white' : 'black';
            ctx.font = '12px Arial';
            ctx.fillText(`${Math.round(Math.abs(brushEndX - brushStartX))}x${Math.round(Math.abs(brushEndY - brushStartY))}`, centerX, centerY);
        }
        
        function drawObject(obj) {
            const x = worldToScreenX(obj.x);
            const y = worldToScreenY(obj.y);
            
            ctx.save();
            ctx.translate(x, y);
            
            if (obj.angle) {
                ctx.rotate(obj.angle * Math.PI / 180);
            }
            
            switch (obj.type) {
                case "brush":
                    const width = (obj.width || 100) * scale;
                    const height = (obj.height || 20) * scale;
                    
                    ctx.fillStyle = 'rgba(173, 216, 230, 0.7)';
                    ctx.strokeStyle = 'blue';
                    ctx.lineWidth = 2;
                    
                    ctx.fillRect(-width/2, -height/2, width, height);
                    ctx.strokeRect(-width/2, -height/2, width, height);
                    break;
                    
                case "player_start":
                        /*const playerColor = obj.properties?.color || '#00FF00';
                        const size = 15 * scale;
                        
                        // –ì–æ–ª–æ–≤–∞
                        ctx.fillStyle = playerColor;
                        ctx.beginPath();
                        ctx.arc(0, -size/2, size/4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        
                        // –¢–µ–ª–æ
                        ctx.beginPath();
                        ctx.moveTo(0, -size/4);
                        ctx.lineTo(0, size/3);
                        ctx.stroke();
                        
                        // –†—É–∫–∏
                        ctx.beginPath();
                        ctx.moveTo(-size/3, 0);
                        ctx.lineTo(size/3, 0);
                        ctx.stroke();
                        
                        // –ù–æ–≥–∏
                        ctx.beginPath();
                        ctx.moveTo(-size/3, size/3);
                        ctx.lineTo(0, size/3);
                        ctx.lineTo(size/3, size/2);
                        ctx.stroke();
                        
                        // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ (—Å—Ç—Ä–µ–ª–∫–∞)
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 1 * scale;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(0, -size);
                        ctx.stroke();
                        
                        // –ì–æ–ª–æ–≤–∫–∞ —Å—Ç—Ä–µ–ª–∫–∏
                        ctx.beginPath();
                        ctx.moveTo(-size/6, -size/1.5);
                        ctx.lineTo(0, -size);
                        ctx.lineTo(size/6, -size/1.5);
                        ctx.stroke();
                        break; */


                    /*/// –ù–æ–≤—ã–π —É–ª—É—á—à–µ–Ω–Ω—ã–π –≤–∏–¥ –¥–ª—è —Ç–æ—á–∫–∏ —Å—Ç–∞—Ä—Ç–∞ –∏–≥—Ä–æ–∫–∞
                    const playerColor = obj.properties?.color || '#00FF00';
                    const radius = 15 * scale;
                    
                    // –û—Å–Ω–æ–≤–Ω–æ–π –∫—Ä—É–≥
                    ctx.fillStyle = playerColor;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // –ö–æ–Ω—Ç—É—Ä
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2 * scale;
                    ctx.stroke();
                    
                    // –ë—É–∫–≤–∞ "P" –≤–Ω—É—Ç—Ä–∏ –∫—Ä—É–≥–∞
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = `${12 * scale}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('P', 0, 0);
                    
                    // –°—Ç—Ä–µ–ª–∫–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2 * scale;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -radius * 2);
                    ctx.stroke();
                    
                    // –ì–æ–ª–æ–≤–∫–∞ —Å—Ç—Ä–µ–ª–∫–∏
                    ctx.beginPath();
                    ctx.moveTo(-5 * scale, -radius * 2 + 10 * scale);
                    ctx.lineTo(0, -radius * 2);
                    ctx.lineTo(5 * scale, -radius * 2 + 10 * scale);
                    ctx.stroke();
                    break;*/


                    ctx.fillStyle = 'green';
                    ctx.beginPath();
                    ctx.arc(0, 0, 10 * scale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
                    ctx.strokeStyle = 'darkgreen';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -20 * scale);
                    ctx.stroke();
                    break;
                    
                case "trigger":
                    ctx.fillStyle = 'rgba(255, 165, 0, 0.5)';
                    ctx.strokeStyle = 'orange';
                    ctx.lineWidth = 2;
                    
                    if (obj.width && obj.height) {
                        const width = (obj.width || 50) * scale;
                        const height = (obj.height || 50) * scale;
                        ctx.beginPath();
                        ctx.rect(-width/2, -height/2, width, height);
                        ctx.fill();
                        ctx.stroke();
                    } else {
                        ctx.beginPath();
                        ctx.arc(0, 0, 15 * scale, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    }
                    break;
                    
                case "light":
                    ctx.fillStyle = 'yellow';
                    ctx.strokeStyle = 'goldenrod';
                    ctx.lineWidth = 2;
                    
                    ctx.beginPath();
                    ctx.arc(0, 0, 12 * scale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // –õ—É—á–∏
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(angle) * 25 * scale, Math.sin(angle) * 25 * scale);
                        ctx.stroke();
                    }
                    break;
                    
                case "prop":
                    ctx.fillStyle = 'lightgray';
                    ctx.strokeStyle = 'gray';
                    ctx.lineWidth = 2;
                    
                    ctx.beginPath();
                    ctx.arc(0, 0, 8 * scale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    break;
            }
            
            // ID –æ–±—ä–µ–∫—Ç–∞
            if (scale > 0.5) {
                ctx.setTransform(1, 0, 0, 1, 0, 0); // –°–±—Ä–æ—Å —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏
                ctx.fillStyle = isDarkTheme ? 'white' : 'black';
                ctx.font = '12px Arial';
                ctx.fillText(obj.id, x + 10, y - 10);
            }
            
            ctx.restore();
        }
        
        function highlightObject(obj) {
            const x = worldToScreenX(obj.x);
            const y = worldToScreenY(obj.y);
            
            ctx.save();
            ctx.translate(x, y);
            
            if (obj.angle) {
                ctx.rotate(obj.angle * Math.PI / 180);
            }
            
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            
            if (obj.type === "brush") {
                const width = (obj.width || 100) * scale;
                const height = (obj.height || 20) * scale;
                
                ctx.strokeRect(-width/2, -height/2, width, height);
            } else {
                ctx.beginPath();
                ctx.arc(0, 0, 20 * scale, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
        function updatePropertiesPanel() {
            document.getElementById('propId').value = selectedObject ? selectedObject.id : '';
            document.getElementById('propType').value = selectedObject ? selectedObject.type : '';
            document.getElementById('propX').value = selectedObject ? selectedObject.x : '';
            document.getElementById('propY').value = selectedObject ? selectedObject.y : '';
            document.getElementById('propWidth').value = selectedObject ? (selectedObject.width || '') : '';
            document.getElementById('propHeight').value = selectedObject ? (selectedObject.height || '') : '';
            document.getElementById('propAngle').value = selectedObject ? (selectedObject.angle || '') : '';
            
            // –í–∫–ª—é—á–∞–µ–º/–≤—ã–∫–ª—é—á–∞–µ–º –ø–æ–ª—è –≤–≤–æ–¥–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞
            const inputs = document.querySelectorAll('.properties-form input');
            inputs.forEach(input => {
                input.disabled = !selectedObject || (input.id !== 'propX' && 
                                                    input.id !== 'propY' && 
                                                    input.id !== 'propWidth' && 
                                                    input.id !== 'propHeight' && 
                                                    input.id !== 'propAngle');
            });
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–Ω–æ–ø–∫–∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è custom properties
            document.getElementById('openCustomPropsBtn').disabled = !selectedObject;
        }
        
        function updateObjectsTable() {
            objectsTableBody.innerHTML = '';
            
            mapData.objects.forEach(obj => {
                const row = document.createElement('tr');
                if (obj === selectedObject) {
                    row.classList.add('selected');
                }
                
                row.innerHTML = `
                    <td>${obj.id}</td>
                    <td>${obj.type}</td>
                    <td>${Math.round(obj.x)}</td>
                    <td>${Math.round(obj.y)}</td>
                `;
                
                objectsTableBody.appendChild(row);
            });
        }
        
        function onObjectsTableClick(e) {
            const row = e.target.closest('tr');
            if (!row) return;
            
            const id = row.cells[0].textContent;
            const obj = mapData.objects.find(o => o.id === id);
            if (obj) {
                selectObject(obj);
            }
        }
        
        function updateObjectProperties() {
            if (!selectedObject) return;
            
            selectedObject.x = parseFloat(document.getElementById('propX').value) || 0;
            selectedObject.y = parseFloat(document.getElementById('propY').value) || 0;
            
            if (selectedObject.type === "brush" || selectedObject.type === "trigger") {
                selectedObject.width = parseFloat(document.getElementById('propWidth').value) || 100;
                selectedObject.height = parseFloat(document.getElementById('propHeight').value) || 20;
            }
            
            if (document.getElementById('propAngle').value) {
                selectedObject.angle = parseFloat(document.getElementById('propAngle').value) || 0;
            }
            
            updateRotateHandlePosition();
            draw();
            updateObjectsTable();
            markDirty();
        }
        
        // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–µ–∂–∏–º–∞–º–∏
        function setMode(mode) {
            currentMode = mode;
            
            // –ï—Å–ª–∏ –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –∏–∑ —Ä–µ–∂–∏–º–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å—Ç–µ–Ω—ã, –æ—Ç–º–µ–Ω—è–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ
            if (isCreatingbrush && mode !== "brush") {
                isCreatingbrush = false;
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω—É—é –∫–Ω–æ–ø–∫—É
            document.querySelectorAll('.toolbar button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            if (mode === "select") {
                document.getElementById('selectBtn').classList.add('active');
                canvas.style.cursor = 'default';
                modeDisplayElem.textContent = "Select";
            } else {
                document.getElementById(mode + 'Btn').classList.add('active');
                canvas.style.cursor = 'crosshair';
                modeDisplayElem.textContent = mode.charAt(0).toUpperCase() + mode.slice(1).replace('_', ' ');
            }
            
            draw();
        }
        
        // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–∏–¥–æ–º
        function setScale(newScale, centerX, centerY) {
            const oldScale = scale;
            scale = Math.max(0.1, Math.min(10, newScale));
            
            // –ï—Å–ª–∏ —É–∫–∞–∑–∞–Ω–∞ —Ç–æ—á–∫–∞ —Ü–µ–Ω—Ç—Ä–∞, –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º —Å–º–µ—â–µ–Ω–∏–µ
            if (centerX !== undefined && centerY !== undefined) {
                const screenX = worldToScreenX(centerX);
                const screenY = worldToScreenY(centerY);
                
                // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ–≤—ã–µ —Å–º–µ—â–µ–Ω–∏—è –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏ –ø–æ–¥ –∫—É—Ä—Å–æ—Ä–æ–º
                offsetX = screenX - centerX * scale;
                offsetY = screenY - centerY * scale;
            }
            
            scaleDisplayElem.textContent = Math.round(scale * 100) + '%';
            updateRotateHandlePosition();
            draw();
        }
        
        function zoomAtCenter(newScale) {
            const centerX = screenToWorldX(canvas.width / 2);
            const centerY = screenToWorldY(canvas.height / 2);
            setScale(newScale, centerX, centerY);
        }
        
        function resetView() {
            offsetX = canvas.width / 2;
            offsetY = canvas.height / 2;
            scale = 1.0;
            scaleDisplayElem.textContent = '100%';
            updateRotateHandlePosition();
            draw();
        }
        
        // –†–∞–±–æ—Ç–∞ —Å —Ñ–∞–π–ª–∞–º–∏
        function showNewMapModal() {
            document.getElementById('newMapModal').style.display = 'flex';
        }
        
        function hideNewMapModal() {
            document.getElementById('newMapModal').style.display = 'none';
        }
        
        function createNewMap() {
            const name = document.getElementById('newMapName').value;
            const author = document.getElementById('newMapAuthor').value;
            const description = document.getElementById('newMapDescription').value;
            
            saveState();
            
            mapData = {
                version: "1.0",
                objects: [],
                metadata: {
                    name: name,
                    author: author,
                    description: description
                }
            };
            
            nextObjectId = 1;
            selectObject(null);
            resetView();
            hideNewMapModal();
            showNotification("New map created");
        }
        
        function openMap() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.vme';
            
            input.onchange = e => {
                const file = e.target.files[0];
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    try {
                        const content = e.target.result;
                        saveState();
                        mapData = JSON.parse(content);
                        
                        // –ù–∞—Ö–æ–¥–∏–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π ID –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è –Ω—É–º–µ—Ä–∞—Ü–∏–∏
                        let maxId = 0;
                        mapData.objects.forEach(obj => {
                            const idNum = parseInt(obj.id.split('_')[1]);
                            if (idNum > maxId) maxId = idNum;
                        });
                        nextObjectId = maxId + 1;
                        
                        // –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ —É –∫–∞–∂–¥–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞ –µ—Å—Ç—å properties
                        mapData.objects.forEach(obj => {
                            if (!obj.properties) {
                                obj.properties = {};
                            }
                        });
                        
                        selectObject(null);
                        resetView();
                        showNotification("Map loaded successfully");
                    } catch (error) {
                        showNotification('Error parsing map file: ' + error.message, true);
                    }
                };
                
                reader.readAsText(file);
            };
            
            input.click();
        }
        
        function saveMap() {
            const dataStr = JSON.stringify(mapData, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportFileDefaultName = `${mapData.metadata.name}.vme`;
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
            
            isDirty = false;
            showNotification("Map saved successfully");
        }
        
        // –ò—Å—Ç–æ—Ä–∏—è –¥–µ–π—Å—Ç–≤–∏–π
        function saveState() {
            // –£–¥–∞–ª—è–µ–º –≤—Å–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ—Å–ª–µ —Ç–µ–∫—É—â–µ–≥–æ –∏–Ω–¥–µ–∫—Å–∞ (–µ—Å–ª–∏ –º—ã –æ—Ç–º–µ–Ω–∏–ª–∏ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –¥–µ–π—Å—Ç–≤–∏—è)
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            history.push(JSON.parse(JSON.stringify(mapData)));
            historyIndex = history.length - 1;
            
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –∏—Å—Ç–æ—Ä–∏–∏
            if (history.length > MAX_HISTORY) {
                history.shift();
                historyIndex--;
            }
            
            updateHistoryButtons();
        }
        
        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                mapData = JSON.parse(JSON.stringify(history[historyIndex]));
                selectObject(null);
                draw();
                updateObjectsTable();
                updateHistoryButtons();
                showNotification("Undo completed");
            }
        }
        
        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                mapData = JSON.parse(JSON.stringify(history[historyIndex]));
                selectObject(null);
                draw();
                updateObjectsTable();
                updateHistoryButtons();
                showNotification("Redo completed");
            }
        }
        
        function updateHistoryButtons() {
            document.getElementById('undoBtn').disabled = historyIndex <= 0;
            document.getElementById('redoBtn').disabled = historyIndex >= history.length - 1;
        }
        
        // –£—Ç–∏–ª–∏—Ç—ã
        function markDirty() {
            isDirty = true;
        }
        
        function toggleTheme() {
            isDarkTheme = !isDarkTheme;
            if (isDarkTheme) {
                document.body.classList.remove("light-theme");
            } else {
                document.body.classList.add("light-theme");
            }
            draw();
        }
        
        function showNotification(message, isError = false) {
            notificationElem.textContent = message;
            notificationElem.className = isError ? "notification error" : "notification";
            notificationElem.style.display = "block";
            
            setTimeout(() => {
                notificationElem.style.display = "none";
            }, 3000);
        }
        
        // Custom properties functions
        function openCustomPropsModal() {
            if (!selectedObject) return;
            
            // Ensure properties object exists
            if (!selectedObject.properties) {
                selectedObject.properties = {};
            }
            
            // Fill the modal with current properties
            updateCustomPropertiesUI();
            
            // Show the modal
            customPropsModal.style.display = 'flex';
        }
        
        function closeCustomPropsModal() {
            customPropsModal.style.display = 'none';
        }
        
        function updateCustomPropertiesUI() {
            customPropertiesContainer.innerHTML = '';
            
            if (!selectedObject || !selectedObject.properties) {
                return;
            }
            
            // Add property fields
            for (const key in selectedObject.properties) {
                addCustomPropertyField(key, selectedObject.properties[key]);
            }
        }
        
        function addCustomPropertyField(key = '', value = '') {
            const propertyRow = document.createElement('div');
            propertyRow.className = 'property-row';
            
            const keyInput = document.createElement('input');
            keyInput.type = 'text';
            keyInput.placeholder = 'Property name';
            keyInput.value = key;
            
            const valueInput = document.createElement('input');
            valueInput.type = 'text';
            valueInput.placeholder = 'Value';
            valueInput.value = value;
            
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-property';
            removeBtn.innerHTML = '√ó';
            removeBtn.addEventListener('click', () => {
                propertyRow.remove();
            });
            
            propertyRow.appendChild(keyInput);
            propertyRow.appendChild(valueInput);
            propertyRow.appendChild(removeBtn);
            
            customPropertiesContainer.appendChild(propertyRow);
        }
        
        function saveCustomProperties() {
            if (!selectedObject) return;
            
            // Ensure properties object exists
            if (!selectedObject.properties) {
                selectedObject.properties = {};
            }
            
            // Clear existing properties
            selectedObject.properties = {};
            
            // Collect all properties from the modal
            const propertyRows = customPropertiesContainer.querySelectorAll('.property-row');
            propertyRows.forEach(row => {
                const keyInput = row.querySelector('input:nth-child(1)');
                const valueInput = row.querySelector('input:nth-child(2)');
                const key = keyInput.value.trim();
                const value = valueInput.value.trim();
                
                if (key) {
                    selectedObject.properties[key] = value;
                }
            });
            
            markDirty();
            closeCustomPropsModal();
            showNotification("Custom properties saved");
        }
        
        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
        document.addEventListener('keydown', e => {
            if (e.key === 'Delete' && selectedObject) {
                deleteSelectedObject();
            } else if (e.key === 'Escape') {
                if (isCreatingbrush) {
                    isCreatingbrush = false;
                    draw();
                } else if (selectedObject) {
                    selectObject(null);
                }
            } else if (e.key === 'g' || e.key === 'G') {
                snapToGrid = !snapToGrid;
                document.getElementById('snapToGridCheckbox').checked = snapToGrid;
                draw();
            } else if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undo();
            } else if (e.ctrlKey && e.key === 'y') {
                e.preventDefault();
                redo();
            } else if (e.key === 'ArrowLeft' && selectedObject) {
                selectedObject.x -= snapToGrid ? GRID_SIZE : 1;
                updatePropertiesPanel();
                updateRotateHandlePosition();
                draw();
            } else if (e.key === 'ArrowRight' && selectedObject) {
                selectedObject.x += snapToGrid ? GRID_SIZE : 1;
                updatePropertiesPanel();
                updateRotateHandlePosition();
                draw();
            } else if (e.key === 'ArrowUp' && selectedObject) {
                selectedObject.y -= snapToGrid ? GRID_SIZE : 1;
                updatePropertiesPanel();
                updateRotateHandlePosition();
                draw();
            } else if (e.key === 'ArrowDown' && selectedObject) {
                selectedObject.y += snapToGrid ? GRID_SIZE : 1;
                updatePropertiesPanel();
                updateRotateHandlePosition();
                draw();
            }
            
            // Tool shortcuts
            if (!e.ctrlKey && !e.altKey && !e.metaKey) {
                switch (e.key.toLowerCase()) {
                    case 'q': setMode('select'); break;
                    case 'b': setMode('brush'); break;
                    case 'p': setMode('player_start'); break;
                    case 't': setMode('trigger'); break;
                    case 'l': setMode('light'); break;
                    case 'o': setMode('prop'); break;
                }
            }
        });

        window.addEventListener("beforeunload", (e) => {
            if (isDirty) {
                e.preventDefault();
                e.returnValue = "";
            }
        });
        
        // –ó–∞–ø—É—Å–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
        window.onload = init;
    </script>
</body>
</html>