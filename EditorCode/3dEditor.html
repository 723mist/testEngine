<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üì¶ VotexMap Editor 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            background-color: #2c3e50;
            color: #ecf0f1;
        }
        
        body.light-theme {
            background-color: #ecf0f1;
            color: #2c3e50;
        }
        
        header {
            background-color: #1a2530;
            color: white;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .light-theme header {
            background-color: #3498db;
            color: white;
        }
        
        .toolbar {
            background-color: #34495e;
            padding: 8px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .light-theme .toolbar {
            background-color: #2980b9;
        }
        
        button {
            padding: 8px 12px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        button.active {
            background-color: #e74c3c;
        }
        
        .light-theme button {
            background-color: #3498db;
        }
        
        .light-theme button:hover {
            background-color: #2980b9;
        }
        
        .light-theme button.active {
            background-color: #e74c3c;
        }
        
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .canvas-container {
            flex: 3;
            position: relative;
            overflow: hidden;
            background-color: #2c3e50;
        }
        
        .light-theme .canvas-container {
            background-color: #bdc3c7;
        }
        
        #mapCanvas {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        .sidebar {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 300px;
            background-color: #34495e;
            border-left: 1px solid #7f8c8d;
        }
        
        .light-theme .sidebar {
            background-color: #ecf0f1;
            border-left: 1px solid #bdc3c7;
        }
        
        .panel {
            margin: 10px;
            padding: 15px;
            background-color: #2c3e50;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .light-theme .panel {
            background-color: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .panel h3 {
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #7f8c8d;
            color: #ecf0f1;
        }
        
        .light-theme .panel h3 {
            color: #2c3e50;
            border-bottom: 1px solid #bdc3c7;
        }
        
        .objects-list {
            height: 200px;
            overflow-y: auto;
            border: 1px solid #7f8c8d;
            border-radius: 4px;
        }
        
        .light-theme .objects-list {
            border: 1px solid #bdc3c7;
        }
        
        .objects-list table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        
        .objects-list th, .objects-list td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #7f8c8d;
            color: #ecf0f1;
        }
        
        .light-theme .objects-list th, 
        .light-theme .objects-list td {
            color: #2c3e50;
            border-bottom: 1px solid #bdc3c7;
        }
        
        .objects-list tr:hover {
            background-color: rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }
        
        .light-theme .objects-list tr:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }
        
        .objects-list tr.selected {
            background-color: #3498db;
        }
        
        .light-theme .objects-list tr.selected {
            background-color: #e3f2fd;
        }
        
        .properties-form {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 10px;
        }
        
        .properties-form label {
            padding: 8px 0;
            font-weight: bold;
            color: #ecf0f1;
        }
        
        .light-theme .properties-form label {
            color: #2c3e50;
        }
        
        .properties-form input {
            padding: 8px;
            border: 1px solid #7f8c8d;
            border-radius: 4px;
            background-color: #34495e;
            color: #ecf0f1;
        }
        
        .light-theme .properties-form input {
            border: 1px solid #bdc3c7;
            background-color: white;
            color: #2c3e50;
        }
        
        .properties-form input:disabled {
            background-color: #2c3e50;
            color: #7f8c8d;
        }
        
        .light-theme .properties-form input:disabled {
            background-color: #f5f5f5;
            color: #bdc3c7;
        }
        
        .status-bar {
            padding: 8px 15px;
            background-color: #34495e;
            color: white;
            display: flex;
            justify-content: space-between;
        }
        
        .light-theme .status-bar {
            background-color: #2980b9;
            color: white;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background-color: #2c3e50;
            padding: 20px;
            border-radius: 8px;
            width: 400px;
            max-width: 90%;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .light-theme .modal-content {
            background-color: white;
        }
        
        .modal h2 {
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #7f8c8d;
            color: #ecf0f1;
        }
        
        .light-theme .modal h2 {
            color: #2c3e50;
            border-bottom: 1px solid #bdc3c7;
        }
        
        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }
        
        .grid-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
        }
        
        .grid-controls label {
            color: #ffffff;
        }
        
        .light-theme .grid-controls label {
            color: #2c3e50;
        }
        
        .grid-controls input {
            width: 60px;
            padding: 4px;
            border: 1px solid #7f8c8d;
            border-radius: 4px;
            background-color: #2c3e50;
            color: #ffffff;
        }
        
        .light-theme .grid-controls input {
            border: 1px solid #bdc3c7;
            background-color: white;
            color: #2c3e50;
        }
        
        .help-text {
            font-size: 12px;
            color: #95a5a6;
            margin-top: 5px;
        }
        
        .light-theme .help-text {
            color: #7f8c8d;
        }
        
        .tooltip {
            position: relative;
            display: inline-block;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 120px;
            background-color: #2c3e50;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -60px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px;
            background-color: #2ecc71;
            color: white;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            display: none;
            z-index: 1000;
        }
        
        .notification.error {
            background-color: #e74c3c;
        }
        
        .grid-snap-mode {
            margin-left: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .grid-snap-mode select {
            padding: 4px;
            border: 1px solid #7f8c8d;
            border-radius: 4px;
            background-color: #2c3e50;
            color: #e3f2fd;
        }
        
        .light-theme .grid-snap-mode select {
            border: 1px solid #bdc3c7;
            background-color: white;
            color: #2c3e50;
        }

        /* New styles for 3D editor */
        .axis-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: 15px;
        }
        
        .axis-controls select {
            padding: 4px;
            border: 1px solid #7f8c8d;
            border-radius: 4px;
            background-color: #2c3e50;
            color: #e3f2fd;
        }
        
        .light-theme .axis-controls select {
            border: 1px solid #bdc3c7;
            background-color: white;
            color: #2c3e50;
        }
        
        .view-controls {
            display: flex;
            gap: 8px;
            margin-left: 15px;
        }
        
        /* Properties form for 3D */
        .properties-form-3d {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 10px;
        }
        
        /* Transform gizmo styles */
        .transform-gizmo {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 5px;
            display: flex;
            gap: 10px;
        }
        
        .gizmo-btn {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            background-color: #3498db;
            cursor: pointer;
        }
        
        .gizmo-btn.active {
            background-color: #e74c3c;
        }
    </style>
    <!-- Three.js library -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <header>
        <h1>üì¶ VotexMap Editor 3D v0.5</h1>
        <div>
            <button id="newBtn">üÜï New</button>
            <button id="openBtn">üìÇ Open</button>
            <button id="saveBtn">üíæ Save</button>
            <button id="undoBtn" title="Undo (Ctrl+Z)">‚Ü©Ô∏è Undo</button>
            <button id="redoBtn" title="Redo (Ctrl+Y)">‚Ü™Ô∏è Redo</button>
            <button id="mapSettingsBtn">‚ÑπÔ∏è Map Settings</button>
            <button id="themeToggleBtn">üé® Dark/Light</button>
            <button id="docBtn">üìÑ Documentation</button>
        </div>
    </header>
    
    <div class="toolbar">
        <button id="selectBtn" class="active">‚ûï Select</button>
        <button id="brushBtn">üñåÔ∏è Brush</button>
        <button id="playerStartBtn">üéÆ Player Start</button>
        <button id="triggerBtn">üïπÔ∏è Trigger</button>
        <button id="lightBtn">üí° Light</button>
        <button id="propBtn">üì¶ Prop</button>
        
        <div class="grid-controls">
            <label>
                <input type="checkbox" id="snapToGridCheckbox" checked>
                Snap to Grid
            </label>
            <label>
                Grid Size:
                <input type="number" id="gridSizeInput" value="1" min="0.1" max="10" step="0.1">
            </label>
        </div>
        
        <div class="axis-controls">
            <label>Axis:</label>
            <select id="transformAxis">
                <option value="x">X</option>
                <option value="y">Y</option>
                <option value="z">Z</option>
            </select>
        </div>
        
        <div class="view-controls">
            <button id="topViewBtn">‚¨ÜÔ∏è Top</button>
            <button id="frontViewBtn">‚¨áÔ∏è Front</button>
            <button id="sideViewBtn">‚¨ÖÔ∏è Side</button>
            <button id="resetViewBtn">üîé Reset View</button>
        </div>
        
        <button id="deleteBtn" style="background-color: #f04b39;">üóëÔ∏è Delete Object</button>
    </div>
    
    <div class="main-container">
        <div class="canvas-container">
            <div id="mapCanvas"></div>
        </div>
        
        <div class="sidebar">
            <div class="panel">
                <h3>Objects</h3>
                <div class="objects-list">
                    <table id="objectsTable">
                        <thead>
                            <tr>
                                <th>ID</th>
                                <th>Type</th>
                                <th>X</th>
                                <th>Y</th>
                                <th>Z</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Objects will be listed here -->
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="panel">
                <h3>Properties</h3>
                <div class="properties-form-3d">
                    <label for="propId">ID:</label>
                    <input type="text" id="propId" disabled>
                    
                    <label for="propType">Type:</label>
                    <input type="text" id="propType" disabled>
                    
                    <label for="propX">X:</label>
                    <input type="number" id="propX" step="0.1">
                    
                    <label for="propY">Y:</label>
                    <input type="number" id="propY" step="0.1">
                    
                    <label for="propZ">Z:</label>
                    <input type="number" id="propZ" step="0.1">
                    
                    <label for="propWidth">Width:</label>
                    <input type="number" id="propWidth" step="0.1">
                    
                    <label for="propHeight">Height:</label>
                    <input type="number" id="propHeight" step="0.1">
                    
                    <label for="propDepth">Depth:</label>
                    <input type="number" id="propDepth" step="0.1">
                    
                    <label for="propRotX">Rot X:</label>
                    <input type="number" id="propRotX" step="1" min="0" max="360">
                    
                    <label for="propRotY">Rot Y:</label>
                    <input type="number" id="propRotY" step="1" min="0" max="360">
                    
                    <label for="propRotZ">Rot Z:</label>
                    <input type="number" id="propRotZ" step="1" min="0" max="360">
                </div>

                <button id="openCustomPropsBtn" class="add-property" style="margin-top: 15px; width: 100%;">Edit Custom Properties</button>
            </div>
        </div>
    </div>
    
    <div class="status-bar">
        <div>X: <span id="cursorX">0</span> | Y: <span id="cursorY">0</span> | Z: <span id="cursorZ">0</span></div>
        <div>Mode: <span id="modeDisplay">Select</span> | Grid: <span id="gridSizeDisplay">1</span></div>
    </div>
    
    <div class="transform-gizmo">
        <div class="gizmo-btn" id="translateGizmo" title="Translate">T</div>
        <div class="gizmo-btn" id="rotateGizmo" title="Rotate">R</div>
        <div class="gizmo-btn" id="scaleGizmo" title="Scale">S</div>
    </div>
    
    <div class="notification" id="notification">Operation completed successfully</div>
    
    <!-- Modals -->
    <div class="modal" id="newMapModal">
        <div class="modal-content">
            <h2>Create New Map</h2>
            <div class="properties-form">
                <label for="newMapName">Name:</label>
                <input type="text" id="newMapName" value="New Map for VE">
                
                <label for="newMapAuthor">Author:</label>
                <input type="text" id="newMapAuthor" value="-">
                
                <label for="newMapDescription">Description:</label>
                <input type="text" id="newMapDescription" value="-">
            </div>
            <div class="modal-buttons">
                <button id="cancelNewMapBtn">Cancel</button>
                <button id="confirmNewMapBtn">Create</button>
            </div>
        </div>
    </div>

    <div class="modal" id="mapSettingsModal">
        <div class="modal-content">
            <h2>Map Settings</h2>
            <div class="properties-form">
                <label for="mapName">Name:</label>
                <input type="text" id="mapName">

                <label for="mapAuthor">Author:</label>
                <input type="text" id="mapAuthor">

                <label for="mapDescription">Description:</label>
                <input type="text" id="mapDescription">

                <label for="mapGridSize">Grid Size:</label>
                <input type="number" id="mapGridSize" min="0.1" max="10" step="0.1">
            </div>
            <div class="modal-buttons">
                <button id="cancelMapSettingsBtn">Cancel</button>
                <button id="confirmMapSettingsBtn">Apply</button>
            </div>
        </div>
    </div>

    <!-- Documentation Modal -->
    <div class="modal" id="documentationModal">
        <div class="modal-content documentation-modal">
            <h2>VotexMap 3D Editor Documentation</h2>
            
            <div class="doc-section">
                <h3>Overview</h3>
                <p>VotexMap Editor 3D is a tool for creating 3D maps for Votex Engine. It allows you to place and configure various objects including brushes, player start positions, triggers, lights, and props in a 3D environment.</p>
            </div>
            
            <div class="doc-section">
                <h3>Controls</h3>
                <ul>
                    <li><span class="doc-shortcut">Left Click</span> - Select object</li>
                    <li><span class="doc-shortcut">Right Click + Drag</span> - Orbit camera</li>
                    <li><span class="doc-shortcut">Middle Click + Drag</span> - Pan camera</li>
                    <li><span class="doc-shortcut">Mouse Wheel</span> - Zoom in/out</li>
                    <li><span class="doc-shortcut">G</span> - Toggle grid snapping</li>
                    <li><span class="doc-shortcut">T/R/S</span> - Switch between Translate/Rotate/Scale modes</li>
                    <li><span class="doc-shortcut">Delete</span> - Delete selected object</li>
                    <li><span class="doc-shortcut">Ctrl+Z</span> - Undo</li>
                    <li><span class="doc-shortcut">Ctrl+Y</span> - Redo</li>
                </ul>
            </div>
            
            <div class="modal-buttons">
                <button id="closeDocBtn">Close</button>
            </div>
        </div>
    </div>

    <script>
        // Three.js variables
        let scene, camera, renderer, controls;
        let gridHelper, axesHelper;
        let raycaster, mouse;
        
        // Editor state
        let GRID_SIZE = 1;
        let selectedObject = null;
        let transformMode = 'translate'; // 'translate', 'rotate', 'scale'
        let transformAxis = 'x';
        let currentMode = 'select';
        let nextObjectId = 1;
        let isDirty = false;
        let isDarkTheme = true;
        
        // Map data
        let mapData = {
            version: "1.0",
            objects: [],
            metadata: {
                name: "NewMap",
                author: "-",
                description: "-"
            }
        };
        
        // History for undo/redo
        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY = 50;
        
        // DOM elements
        const container = document.getElementById('mapCanvas');
        const cursorXElem = document.getElementById('cursorX');
        const cursorYElem = document.getElementById('cursorY');
        const cursorZElem = document.getElementById('cursorZ');
        const gridSizeDisplayElem = document.getElementById('gridSizeDisplay');
        const modeDisplayElem = document.getElementById('modeDisplay');
        const notificationElem = document.getElementById('notification');
        const objectsTableBody = document.querySelector('#objectsTable tbody');
        const gridSizeInput = document.getElementById('gridSizeInput');
        
        // Initialize Three.js scene
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2c3e50);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);
            
            // Add OrbitControls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Add grid helper
            gridHelper = new THREE.GridHelper(20, 20, 0x888888, 0x444444);
            scene.add(gridHelper);
            
            // Add axes helper
            axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);
            
            // Setup raycaster for object selection
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(1, 1, 1);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Add a point light for better illumination
            const pointLight = new THREE.PointLight(0xffffff, 0.5);
            pointLight.position.set(5, 10, 5);
            scene.add(pointLight);
            
            // Event listeners
            setupEventListeners();
            window.addEventListener('resize', onWindowResize);
            
            // Start animation loop
            animate();
            
            showNotification("3D Editor initialized successfully");
        }
        
        function setupEventListeners() {
            // Tool buttons
            document.getElementById('selectBtn').addEventListener('click', () => setMode('select'));
            document.getElementById('brushBtn').addEventListener('click', () => setMode('brush'));
            document.getElementById('playerStartBtn').addEventListener('click', () => setMode('player_start'));
            document.getElementById('triggerBtn').addEventListener('click', () => setMode('trigger'));
            document.getElementById('lightBtn').addEventListener('click', () => setMode('light'));
            document.getElementById('propBtn').addEventListener('click', () => setMode('prop'));
            
            // View controls
            document.getElementById('topViewBtn').addEventListener('click', setTopView);
            document.getElementById('frontViewBtn').addEventListener('click', setFrontView);
            document.getElementById('sideViewBtn').addEventListener('click', setSideView);
            document.getElementById('resetViewBtn').addEventListener('click', resetView);
            
            // Grid controls
            document.getElementById('snapToGridCheckbox').addEventListener('change', (e) => {
                gridHelper.visible = e.target.checked;
            });
            
            gridSizeInput.addEventListener('change', (e) => {
                GRID_SIZE = parseFloat(e.target.value) || 1;
                gridHelper.size = 20;
                gridHelper.divisions = Math.floor(20 / GRID_SIZE);
                gridSizeDisplayElem.textContent = GRID_SIZE.toFixed(1);
            });
            
            // Transform axis
            document.getElementById('transformAxis').addEventListener('change', (e) => {
                transformAxis = e.target.value;
            });
            
            // Gizmo buttons
            document.getElementById('translateGizmo').addEventListener('click', () => setTransformMode('translate'));
            document.getElementById('rotateGizmo').addEventListener('click', () => setTransformMode('rotate'));
            document.getElementById('scaleGizmo').addEventListener('click', () => setTransformMode('scale'));
            
            // File operations
            document.getElementById('newBtn').addEventListener('click', showNewMapModal);
            document.getElementById('openBtn').addEventListener('click', openMap);
            document.getElementById('saveBtn').addEventListener('click', saveMap);
            document.getElementById('confirmNewMapBtn').addEventListener('click', createNewMap);
            document.getElementById('cancelNewMapBtn').addEventListener('click', hideNewMapModal);
            
            // Undo/redo
            document.getElementById('undoBtn').addEventListener('click', undo);
            document.getElementById('redoBtn').addEventListener('click', redo);
            
            // Delete button
            document.getElementById('deleteBtn').addEventListener('click', deleteSelectedObject);
            
            // Properties inputs
            document.getElementById('propX').addEventListener('change', updateObjectProperties);
            document.getElementById('propY').addEventListener('change', updateObjectProperties);
            document.getElementById('propZ').addEventListener('change', updateObjectProperties);
            document.getElementById('propWidth').addEventListener('change', updateObjectProperties);
            document.getElementById('propHeight').addEventListener('change', updateObjectProperties);
            document.getElementById('propDepth').addEventListener('change', updateObjectProperties);
            document.getElementById('propRotX').addEventListener('change', updateObjectProperties);
            document.getElementById('propRotY').addEventListener('change', updateObjectProperties);
            document.getElementById('propRotZ').addEventListener('change', updateObjectProperties);
            
            // Canvas events
            renderer.domElement.addEventListener('mousedown', onCanvasMouseDown, false);
            renderer.domElement.addEventListener('mousemove', onCanvasMouseMove, false);
            renderer.domElement.addEventListener('mouseup', onCanvasMouseUp, false);
            renderer.domElement.addEventListener('wheel', onCanvasWheel, false);
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // Map Settings
            document.getElementById("mapSettingsBtn").addEventListener("click", showMapSettingsModal);
            document.getElementById("cancelMapSettingsBtn").addEventListener("click", hideMapSettingsModal);
            document.getElementById("confirmMapSettingsBtn").addEventListener("click", applyMapSettings);
            
            // Theme toggle
            document.getElementById("themeToggleBtn").addEventListener("click", toggleTheme);
            
            // Documentation
            document.getElementById("docBtn").addEventListener("click", showDocumentationModal);
            document.getElementById("closeDocBtn").addEventListener("click", hideDocumentationModal);
        }
        
        function onWindowResize() {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Object creation
        function addObject(type, position) {
            let geometry, material, mesh;
            
            switch (type) {
                case "brush":
                    geometry = new THREE.BoxGeometry(2, 1, 1);
                    material = new THREE.MeshPhongMaterial({ 
                        color: 0x3498db, 
                        transparent: true, 
                        opacity: 0.7 
                    });
                    mesh = new THREE.Mesh(geometry, material);
                    break;
                    
                case "player_start":
                    geometry = new THREE.ConeGeometry(0.5, 1, 8);
                    material = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.rotation.x = Math.PI; // Flip the cone
                    break;
                    
                case "trigger":
                    geometry = new THREE.BoxGeometry(1, 1, 1);
                    material = new THREE.MeshPhongMaterial({ 
                        color: 0xff9900, 
                        transparent: true, 
                        opacity: 0.5 
                    });
                    mesh = new THREE.Mesh(geometry, material);
                    break;
                    
                case "light":
                    geometry = new THREE.SphereGeometry(0.3, 16, 16);
                    material = new THREE.MeshPhongMaterial({ 
                        color: 0xffff00, 
                        emissive: 0xffff00 
                    });
                    mesh = new THREE.Mesh(geometry, material);
                    
                    // Add a point light
                    const pointLight = new THREE.PointLight(0xffffff, 1, 10);
                    pointLight.position.copy(position);
                    scene.add(pointLight);
                    mesh.userData.light = pointLight;
                    break;
                    
                case "prop":
                    geometry = new THREE.SphereGeometry(0.4, 16, 16);
                    material = new THREE.MeshPhongMaterial({ color: 0x888888 });
                    mesh = new THREE.Mesh(geometry, material);
                    break;
            }
            
            mesh.position.copy(position);
            mesh.userData = {
                id: `obj_${nextObjectId++}`,
                type: type,
                properties: {}
            };
            
            scene.add(mesh);
            mapData.objects.push(mesh.userData);
            selectObject(mesh);
            
            updateObjectsTable();
            showNotification(`Added ${type.replace('_', ' ')} object`);
        }
        
        function selectObject(object3D) {
            // Remove selection from previous object
            if (selectedObject) {
                selectedObject.material.emissive.setHex(selectedObject.userData.originalEmissive || 0x000000);
            }
            
            selectedObject = object3D;
            
            // Highlight new object
            if (selectedObject) {
                selectedObject.userData.originalEmissive = selectedObject.material.emissive.getHex();
                selectedObject.material.emissive.setHex(0xff0000);
            }
            
            updatePropertiesPanel();
            updateObjectsTable();
        }
        
        function findObjectAtMouse(event) {
            // Calculate mouse position in normalized device coordinates
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Update the raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Find intersected objects
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            // Ignore helpers
            for (let i = 0; i < intersects.length; i++) {
                if (intersects[i].object !== gridHelper && 
                    intersects[i].object !== axesHelper &&
                    !intersects[i].object.userData.isHelper) {
                    return intersects[i].object;
                }
            }
            
            return null;
        }
        
        // Event handlers
        function onCanvasMouseDown(event) {
            event.preventDefault();
            
            const object = findObjectAtMouse(event);
            
            if (event.button === 0) { // Left click
                if (object) {
                    selectObject(object);
                } else {
                    // If no object clicked, check if we're in placement mode
                    if (currentMode !== 'select') {
                        // Calculate position in world space
                        raycaster.setFromCamera(mouse, camera);
                        const intersects = raycaster.intersectObject(gridHelper);
                        
                        if (intersects.length > 0) {
                            const point = intersects[0].point;
                            addObject(currentMode, point);
                        }
                    } else {
                        selectObject(null);
                    }
                }
            }
        }
        
        function onCanvasMouseMove(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Update cursor position display
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(gridHelper);
            
            if (intersects.length > 0) {
                const point = intersects[0].point;
                cursorXElem.textContent = point.x.toFixed(1);
                cursorYElem.textContent = point.y.toFixed(1);
                cursorZElem.textContent = point.z.toFixed(1);
            }
        }
        
        function onCanvasMouseUp(event) {
            // Handle mouse up events if needed
        }
        
        function onCanvasWheel(event) {
            // Let OrbitControls handle zooming
        }
        
        // View controls
        function setTopView() {
            camera.position.set(0, 15, 0);
            camera.lookAt(0, 0, 0);
            controls.update();
        }
        
        function setFrontView() {
            camera.position.set(0, 0, 15);
            camera.lookAt(0, 0, 0);
            controls.update();
        }
        
        function setSideView() {
            camera.position.set(15, 0, 0);
            camera.lookAt(0, 0, 0);
            controls.update();
        }
        
        function resetView() {
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);
            controls.update();
        }
        
        // UI update functions
        function updatePropertiesPanel() {
            if (selectedObject) {
                document.getElementById('propId').value = selectedObject.userData.id;
                document.getElementById('propType').value = selectedObject.userData.type;
                document.getElementById('propX').value = selectedObject.position.x.toFixed(1);
                document.getElementById('propY').value = selectedObject.position.y.toFixed(1);
                document.getElementById('propZ').value = selectedObject.position.z.toFixed(1);
                
                if (selectedObject.userData.type === 'brush' || selectedObject.userData.type === 'trigger') {
                    document.getElementById('propWidth').value = selectedObject.scale.x * 2;
                    document.getElementById('propHeight').value = selectedObject.scale.y * 1;
                    document.getElementById('propDepth').value = selectedObject.scale.z * 1;
                }
                
                document.getElementById('propRotX').value = (selectedObject.rotation.x * 180 / Math.PI).toFixed(0);
                document.getElementById('propRotY').value = (selectedObject.rotation.y * 180 / Math.PI).toFixed(0);
                document.getElementById('propRotZ').value = (selectedObject.rotation.z * 180 / Math.PI).toFixed(0);
            } else {
                // Clear properties panel
                const inputs = document.querySelectorAll('.properties-form-3d input');
                inputs.forEach(input => {
                    if (input.id !== 'propId' && input.id !== 'propType') {
                        input.value = '';
                    }
                });
            }
            
            // Enable/disable inputs based on selection
            const inputs = document.querySelectorAll('.properties-form-3d input');
            inputs.forEach(input => {
                input.disabled = !selectedObject || (input.id !== 'propX' && 
                                                    input.id !== 'propY' && 
                                                    input.id !== 'propZ' && 
                                                    input.id !== 'propWidth' && 
                                                    input.id !== 'propHeight' && 
                                                    input.id !== 'propDepth' &&
                                                    input.id !== 'propRotX' && 
                                                    input.id !== 'propRotY' && 
                                                    input.id !== 'propRotZ');
            });
            
            document.getElementById('openCustomPropsBtn').disabled = !selectedObject;
        }
        
        function updateObjectsTable() {
            objectsTableBody.innerHTML = '';
            
            mapData.objects.forEach(objData => {
                const row = document.createElement('tr');
                
                // Find the corresponding object in the scene
                let obj = null;
                scene.children.forEach(child => {
                    if (child.userData && child.userData.id === objData.id) {
                        obj = child;
                    }
                });
                
                if (obj === selectedObject) {
                    row.classList.add('selected');
                }
                
                row.innerHTML = `
                    <td>${objData.id}</td>
                    <td>${objData.type}</td>
                    <td>${obj ? obj.position.x.toFixed(1) : '0'}</td>
                    <td>${obj ? obj.position.y.toFixed(1) : '0'}</td>
                    <td>${obj ? obj.position.z.toFixed(1) : '0'}</td>
                `;
                
                row.addEventListener('click', () => {
                    if (obj) {
                        selectObject(obj);
                    }
                });
                
                objectsTableBody.appendChild(row);
            });
        }
        
        function updateObjectProperties() {
            if (!selectedObject) return;
            
            // Update position
            selectedObject.position.x = parseFloat(document.getElementById('propX').value) || 0;
            selectedObject.position.y = parseFloat(document.getElementById('propY').value) || 0;
            selectedObject.position.z = parseFloat(document.getElementById('propZ').value) || 0;
            
            // Update scale for brush and trigger objects
            if (selectedObject.userData.type === 'brush' || selectedObject.userData.type === 'trigger') {
                selectedObject.scale.x = parseFloat(document.getElementById('propWidth').value) / 2 || 1;
                selectedObject.scale.y = parseFloat(document.getElementById('propHeight').value) || 1;
                selectedObject.scale.z = parseFloat(document.getElementById('propDepth').value) || 1;
            }
            
            // Update rotation
            selectedObject.rotation.x = (parseFloat(document.getElementById('propRotX').value) || 0) * Math.PI / 180;
            selectedObject.rotation.y = (parseFloat(document.getElementById('propRotY').value) || 0) * Math.PI / 180;
            selectedObject.rotation.z = (parseFloat(document.getElementById('propRotZ').value) || 0) * Math.PI / 180;
            
            updateObjectsTable();
            markDirty();
        }
        
        // Mode and transform controls
        function setMode(mode) {
            currentMode = mode;
            
            // Update active button
            document.querySelectorAll('.toolbar button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            if (mode === "select") {
                document.getElementById('selectBtn').classList.add('active');
                modeDisplayElem.textContent = "Select";
            } else {
                document.getElementById(mode + 'Btn').classList.add('active');
                modeDisplayElem.textContent = mode.charAt(0).toUpperCase() + mode.slice(1).replace('_', ' ');
            }
        }
        
        function setTransformMode(mode) {
            transformMode = mode;
            
            // Update active gizmo button
            document.querySelectorAll('.gizmo-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            document.getElementById(mode + 'Gizmo').classList.add('active');
        }
        
        // File operations
        function showNewMapModal() {
            document.getElementById('newMapModal').style.display = 'flex';
        }
        
        function hideNewMapModal() {
            document.getElementById('newMapModal').style.display = 'none';
        }
        
        function createNewMap() {
            const name = document.getElementById('newMapName').value;
            const author = document.getElementById('newMapAuthor').value;
            const description = document.getElementById('newMapDescription').value;
            
            saveState();
            
            // Clear the scene
            while(scene.children.length > 0) { 
                scene.remove(scene.children[0]); 
            }
            
            // Readd grid and axes
            scene.add(gridHelper);
            scene.add(axesHelper);
            
            // Reset map data
            mapData = {
                version: "1.0",
                objects: [],
                metadata: {
                    name: name,
                    author: author,
                    description: description
                }
            };
            
            nextObjectId = 1;
            selectObject(null);
            resetView();
            hideNewMapModal();
            showNotification("New map created");
        }
        
        function openMap() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.vme';
            
            input.onchange = e => {
                const file = e.target.files[0];
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    try {
                        const content = e.target.result;
                        saveState();
                        const loadedData = JSON.parse(content);
                        
                        // Clear the scene
                        while(scene.children.length > 0) { 
                            scene.remove(scene.children[0]); 
                        }
                        
                        // Readd grid and axes
                        scene.add(gridHelper);
                        scene.add(axesHelper);
                        
                        // Load map data
                        mapData = loadedData;
                        
                        // Recreate objects in the scene
                        mapData.objects.forEach(objData => {
                            let geometry, material, mesh;
                            
                            switch (objData.type) {
                                case "brush":
                                    geometry = new THREE.BoxGeometry(2, 1, 1);
                                    material = new THREE.MeshPhongMaterial({ 
                                        color: 0x3498db, 
                                        transparent: true, 
                                        opacity: 0.7 
                                    });
                                    mesh = new THREE.Mesh(geometry, material);
                                    break;
                                    
                                case "player_start":
                                    geometry = new THREE.ConeGeometry(0.5, 1, 8);
                                    material = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
                                    mesh = new THREE.Mesh(geometry, material);
                                    mesh.rotation.x = Math.PI;
                                    break;
                                    
                                case "trigger":
                                    geometry = new THREE.BoxGeometry(1, 1, 1);
                                    material = new THREE.MeshPhongMaterial({ 
                                        color: 0xff9900, 
                                        transparent: true, 
                                        opacity: 0.5 
                                    });
                                    mesh = new THREE.Mesh(geometry, material);
                                    break;
                                    
                                case "light":
                                    geometry = new THREE.SphereGeometry(0.3, 16, 16);
                                    material = new THREE.MeshPhongMaterial({ 
                                        color: 0xffff00, 
                                        emissive: 0xffff00 
                                    });
                                    mesh = new THREE.Mesh(geometry, material);
                                    
                                    // Add a point light
                                    const pointLight = new THREE.PointLight(0xffffff, 1, 10);
                                    pointLight.position.set(objData.x, objData.y, objData.z);
                                    scene.add(pointLight);
                                    mesh.userData.light = pointLight;
                                    break;
                                    
                                case "prop":
                                    geometry = new THREE.SphereGeometry(0.4, 16, 16);
                                    material = new THREE.MeshPhongMaterial({ color: 0x888888 });
                                    mesh = new THREE.Mesh(geometry, material);
                                    break;
                            }
                            
                            mesh.position.set(objData.x, objData.y, objData.z);
                            mesh.userData = objData;
                            
                            if (objData.width && objData.height && objData.depth) {
                                mesh.scale.set(objData.width/2, objData.height, objData.depth);
                            }
                            
                            if (objData.rotation) {
                                mesh.rotation.set(
                                    objData.rotation.x * Math.PI / 180,
                                    objData.rotation.y * Math.PI / 180,
                                    objData.rotation.z * Math.PI / 180
                                );
                            }
                            
                            scene.add(mesh);
                        });
                        
                        // Find max ID for continued numbering
                        let maxId = 0;
                        mapData.objects.forEach(obj => {
                            const idNum = parseInt(obj.id.split('_')[1]);
                            if (idNum > maxId) maxId = idNum;
                        });
                        nextObjectId = maxId + 1;
                        
                        selectObject(null);
                        resetView();
                        showNotification("Map loaded successfully");
                    } catch (error) {
                        showNotification('Error parsing map file: ' + error.message, true);
                    }
                };
                
                reader.readAsText(file);
            };
            
            input.click();
        }
        
        function saveMap() {
            // Update object data from scene objects
            mapData.objects.forEach(objData => {
                scene.children.forEach(child => {
                    if (child.userData && child.userData.id === objData.id) {
                        objData.x = child.position.x;
                        objData.y = child.position.y;
                        objData.z = child.position.z;
                        
                        if (child.userData.type === 'brush' || child.userData.type === 'trigger') {
                            objData.width = child.scale.x * 2;
                            objData.height = child.scale.y;
                            objData.depth = child.scale.z;
                        }
                        
                        objData.rotation = {
                            x: child.rotation.x * 180 / Math.PI,
                            y: child.rotation.y * 180 / Math.PI,
                            z: child.rotation.z * 180 / Math.PI
                        };
                    }
                });
            });
            
            const dataStr = JSON.stringify(mapData, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportFileDefaultName = `${mapData.metadata.name}.vme`;
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
            
            isDirty = false;
            showNotification("Map saved successfully");
        }
        
        function deleteSelectedObject() {
            if (!selectedObject) {
                showNotification("No object selected to delete", true);
                return;
            }
            
            // Remove light if it's a light object
            if (selectedObject.userData.light) {
                scene.remove(selectedObject.userData.light);
            }
            
            // Remove from scene
            scene.remove(selectedObject);
            
            // Remove from map data
            const index = mapData.objects.findIndex(obj => obj.id === selectedObject.userData.id);
            if (index !== -1) {
                mapData.objects.splice(index, 1);
            }
            
            selectObject(null);
            updateObjectsTable();
            showNotification("Object deleted");
        }
        
        // Map settings
        function showMapSettingsModal() {
            document.getElementById("mapSettingsModal").style.display = "flex";
            document.getElementById("mapName").value = mapData.metadata.name;
            document.getElementById("mapAuthor").value = mapData.metadata.author;
            document.getElementById("mapDescription").value = mapData.metadata.description;
            document.getElementById("mapGridSize").value = GRID_SIZE;
        }
        
        function hideMapSettingsModal() {
            document.getElementById("mapSettingsModal").style.display = "none";
        }
        
        function applyMapSettings() {
            mapData.metadata.name = document.getElementById("mapName").value;
            mapData.metadata.author = document.getElementById("mapAuthor").value;
            mapData.metadata.description = document.getElementById("mapDescription").value;
            GRID_SIZE = parseFloat(document.getElementById("mapGridSize").value) || GRID_SIZE;
            gridSizeInput.value = GRID_SIZE;
            gridSizeDisplayElem.textContent = GRID_SIZE.toFixed(1);
            
            // Update grid
            gridHelper.size = 20;
            gridHelper.divisions = Math.floor(20 / GRID_SIZE);
            
            hideMapSettingsModal();
            markDirty();
            showNotification("Map settings updated");
        }
        
        // History functions
        function saveState() {
            // This would save the current state for undo/redo
            // Implementation would be similar to the 2D version but with 3D data
        }
        
        function undo() {
            // Undo implementation
        }
        
        function redo() {
            // Redo implementation
        }
        
        function updateHistoryButtons() {
            // Update undo/redo buttons state
        }
        
        // Utility functions
        function markDirty() {
            isDirty = true;
        }
        
        function toggleTheme() {
            isDarkTheme = !isDarkTheme;
            if (isDarkTheme) {
                document.body.classList.remove("light-theme");
                scene.background = new THREE.Color(0x2c3e50);
            } else {
                document.body.classList.add("light-theme");
                scene.background = new THREE.Color(0xecf0f1);
            }
        }
        
        function showNotification(message, isError = false) {
            notificationElem.textContent = message;
            notificationElem.className = isError ? "notification error" : "notification";
            notificationElem.style.display = "block";
            
            setTimeout(() => {
                notificationElem.style.display = "none";
            }, 3000);
        }
        
        function showDocumentationModal() {
            document.getElementById("documentationModal").style.display = "flex";
        }
        
        function hideDocumentationModal() {
            document.getElementById("documentationModal").style.display = "none";
        }
        
        // Initialize the editor
        window.onload = init;
    </script>
</body>
</html>